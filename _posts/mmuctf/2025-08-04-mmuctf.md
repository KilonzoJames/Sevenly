---
title: "MMU CyberShield CTF 2025: Forensics Write-ups"
date: 2025-08-04 00:00:00 +0800
categories: [ctf, forensics]
tags: [ctf, mmuctf2025, forensics]
description: "Comprehensive write-ups for the MMU CyberShield CTF 2025 forensics challenges, including 'Find The City', 'Just BC', 'Conundrum', and 'Coat of many Layers'. Explore solutions involving disk image analysis, data recovery, LLVM IR analysis, and multi-stage decryption."
---


# Find The City Challenge

![Find The City Challenge](/dzif8ltvg/image/upload/v1754291813/CTF/MMU%20CyberShield%20CTF/mmuctf2025-cybershield.up.railway.app_challenges_7_kjqf0k.png){: width="400" height="400"}

---

## Challenge Overview

Imagine a $1,000 reward for simply finding someone's favorite city. That was the premise of the "Find The City" challenge. We were handed a mysterious USB key, told it contained the secret, and tasked with unearthing this elusive city from its disk image. Success hinged on meticulously exploring the image's hidden data to reveal the flag.

---

## Task Brief

The goal was to analyze the provided usb.img disk image file, extract hidden information, and ultimately identify the name of a city, which served as the flag for this challenge.

---

## Solve Process
To begin the challenge, we inspected and mounted the disk image to access its file system.

### Step 1: Disk Image Examination and Mounting
We started by listing the partitions within the `usb.img` file using `fdisk -l` to understand its structure.

```bash
$ fdisk -l usb.img
Disk usb.img: 100 MiB, 104857600 bytes, 204800 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

Next, we created a mount point and mounted the disk image to access its file system.

```bash
sudo mkdir /mnt/usbimg
sudo mount -o loop usb.img /mnt/usbimg
```

---

### Step 2: Initial File System Exploration

After successfully mounting the image, we listed the contents of the mounted directory to identify potentially relevant files.

```bash
$ ls -la /mnt/usbimg
total 7803
# ... (other files, redacted for brevity)
-rw-r--r--  1 root root 104566 Aug  1 11:00 important.jpeg
drwx------  2 root root  12288 Aug  1 10:58 lost+found
-rw-r--r--  1 root root     80 Aug  1 11:00 secret_pass
```

Among the various files, `important.jpeg` and `secret_pass` immediately stood out as potential sources of information.

---

### Step 3: Analyzing `important.jpeg`
Given that `important.jpeg` was an image file, our first instinct was to view it:

```bash
eog important.jpeg
```

The image displayed text stating **"FLAG IS HERE!"**. While this was a direct hint, it's common in CTFs for crucial data to be hidden within images through steganography. We initially tried `binwalk` to extract any embedded files:

```bash
$ binwalk -e important.jpeg

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             JPEG image data, JFIF standard 1.01
```

`binwalk` didn't immediately yield any extracted files, suggesting the hidden information might not be a separate embedded file. We then used the `strings` utility to search for printable strings within the `important.jpeg` file, hoping to uncover hidden text.

```bash
$ strings important.jpeg
JFIF
Ithe file is aes-256-cbc protected but you have key: "n0t_3asy_to_f1nd!"
$3br
# ... (redacted for brevity)
```

This command revealed a hidden message: the file is aes-256-cbc protected but you have key: "n0t_3asy_to_f1nd!"

This message was a major breakthrough! We now knew that `secret_pass` was indeed encrypted using AES-256-CBC and, more importantly, providing the encryption key: "n0t_3asy_to_f1nd!".

---

### Step 4: Decrypting secret_pass
With the encryption key in hand, the next logical step was to decrypt `secret_pass` using `openssl`. We first confirmed the file's header, which suggested `openssl` encryption due to the "Salted__" prefix.

```bash
$ xxd secret_pass 
00000000: 5361 6c74 6564 5f5f 243d a18e d100 3f09  Salted__$=....?.
00000010: f577 8589 13c1 07f4 4457 1616 6ecc eea3  .w......DW..n...
# ... (redacted for brevity)
```

We then used `openssl` to decrypt `secret_pass`, specifying the AES-256-CBC cipher, providing the discovered key, and utilizing the `-pbkdf2` flag for robust key derivation in `openssl` decryption.

```bash
openssl enc -d -aes-256-cbc -in secret_pass -out ~/Downloads/decrypted.txt -k "n0t_3asy_to_f1nd!" -pbkdf2
```

After successful decryption, we examined the contents of the decrypted.txt file.

---

### Step 5: Discovering the City
The decrypted.txt file contained the following geographical coordinates and information:

```bash
$ cat ~/Downloads/decrypted.txt
This city: 
Latitude:55.916667 
Longitude:37.816667
```

Proceeding to Google Maps (or any geolocation service), a search using these coordinates (Latitude: 55.916667, Longitude: 37.816667) quickly revealed the corresponding location:

`WR88+MM7 Korolyov, Russia`

The coordinates and the provided Plus Code (WR88+MM7) definitively pointed to Korolyov, Russia, confirming this as the favorite city. The challenge implicitly suggested the flag format would be related to the city's name.

---

### Step 6: Unmounting the Drive
As a good practice in forensics, it's essential to unmount the disk image after analysis is complete.

```bash
$ cd ~ # Change directory to somewhere outside the mounted image
$ sudo umount /mnt/usbimg
[sudo] password for sevenly: 
```
---

## The Verdict

Based on the decrypted information and geolocation, the flag for the "Find The City" challenge is `mmuctf{Korolyov}`.

---

## ðŸ§© Summary
This challenge served as an excellent demonstration of combining fundamental forensic techniques. The solve process involved:

- **Disk Image Analysis**: Mounting and exploring a disk image to identify suspicious files.
- **Steganography Detection**: Utilizing `strings` to uncover hidden information within a JPEG image, specifically an encryption key.
- **Cryptographic Decryption**: Applying `openssl` to decrypt a sensitive file using the recovered key.
- **Geolocation**: Using coordinates obtained from the decrypted data to identify the target city.

The challenge effectively highlighted the importance of a thorough and multi-faceted approach to digital forensics, where even seemingly innocuous files can hold crucial clues.

---





# Just BC Challenge

![Just BC Challenge](/dzif8ltvg/image/upload/v1754291812/CTF/MMU%20CyberShield%20CTF/mmuctf2025-cybershield.up.railway.app_challenges_6_aditod.png){: width="400" height="400"}

---

## Challenge Overview

The "Just BC" challenge, worth 150 points, posed an intriguing question: "What type needs THIS much security?" Participants were given a file named `just-bc.bin` and a crucial hint: "note the password required is inside this file." The ultimate goal was to submit this password to a specified netcat connection.

---

## Task Brief
The core task was to analyze the provided `just-bc.bin` file, extract a hidden password from it, and then use that password to interact with a netcat service to receive the final flag.

---

## Solution Approach
The challenge provided a binary file without immediately specifying its type. Our first step was to identify the file format, which would dictate our approach to extracting the password.

### Step 1: Identifying the File Type
We started by using the `file` command to determine the nature of `just-bc.bin`:

```bash
$ file just-bc.bin
just-bc.bin: LLVM IR bitcode
```

The output revealed that `just-bc.bin` was an LLVM IR bitcode file. This is a low-level intermediate representation often used by compilers like Clang before generating machine code.

### Step 2: Disassembling the LLVM IR Bitcode
Since it was LLVM IR bitcode, we knew we could disassemble it into human-readable LLVM assembly (`.ll` file) using `llvm-dis`. This would allow us to inspect the code for the hidden password.

```bash
llvm-dis just-bc.bin -o just-bc.ll
```

This command successfully converted the binary bitcode into a text-based LLVM assembly file named `just-bc.ll`.

### Step 3: Extracting the Password
Next, we opened `just-bc.ll` using a text editor or viewed its contents using `cat` or `less`. We specifically looked for embedded strings or constants that might represent the password. 

A quick search for `"Password"` (or similar keywords, or simply visually scanning for obvious strings) led us directly to a private constant string:

Code snippet
```llvm
@anon.112aa5216417f3e30cbfa40815f3b444.61 = private unnamed_addr constant <{ [30 x i8] }> <{ [30 x i8] c"lmaoniceonebuddypalfriendolino" }>, align 1
```

**The password was clearly identified as:** `lmaoniceonebuddypalfriendolino`

### Step 4: Interacting with the Netcat Service
With the password in hand, the final step was to connect to the provided Netcat server and submit it. The challenge description specified the address and port: `simulations.cyberchiefgames.tech 1000`.

We used `echo` to pipe the password directly to the Netcat connection:

```bash
echo "lmaoniceonebuddypalfriendolino" | nc simulations.cyberchiefgames.tech 1000
```

Upon submitting the password, the server responded:
```bash
Password: 
mmuctf{hmm_y3s_1nteresting_v3ry_1nteresting}
```

The response provided the flag!

---

## The Verdict
The flag for the "Just BC" challenge is  
`mmuctf{hmm_y3s_1nteresting_v3ry_1nteresting}`.

---

## ðŸ§© Summary
This challenge was a straightforward yet effective introduction to analyzing LLVM IR bitcode. The key steps involved:

1. **File Type Identification**: Using `file` to determine the binary's format.

2. **Disassembly**: Employing `llvm-dis` to convert the bitcode into human-readable assembly.

3. **String Extraction**: Identifying the hardcoded password within the disassembled code.

4. **Network Interaction**: Submitting the extracted password to a `netcat` service to retrieve the flag.

This challenge demonstrated a common technique in reverse engineering and forensics: analyzing obscure binary formats to uncover hidden data.

---





# Conundrum Challenge

![Conundrum Challenge](/dzif8ltvg/image/upload/v1754291812/CTF/MMU%20CyberShield%20CTF/mmuctf2025-cybershield.up.railway.app_challenges_5_ltrkm1.png){: width="400" height="400"}

---

## Challenge Overview
The **"Conundrum"** challenge, worth **100 points**, plunged participants into a classic digital forensics scenario: **data recovery after an accidental deletion**. The premise involved an intern's mishap, necessitating the retrieval of a crucial, deleted file from a provided disk image.

---

## Task Brief
The primary objective was straightforward: **recover a deleted "important file"** from the provided `usb_drive.img` disk image, which was presumed to contain the flag or a path to it.

---

## Solve Process
Given the challenge description, our immediate strategy was to employ data recovery techniques on the provided disk image.

### Step 1: Recovering Deleted Files with PhotoRec

PhotoRec is a powerful data recovery utility that can recover lost files from various file systems, even if they are severely damaged or reformatted. We used it on `usb_drive.img` to initiate the recovery:

```bash
photorec usb_drive.img
```

PhotoRec created a recovery directory (typically named `recup_dir.1`, `recup_dir.2`, etc.) containing the recovered files. We navigated into the first one to examine its contents:

```bash
cd recup_dir.1/
```

A quick listing of the directory's contents (`ls -la`) revealed a trove of recovered files. Among them, two immediately piqued our interest: `f0000476_confidential.zip` and `f0000440.jpg`.

### Step 2: Cracking the ZIP Archive
The discovery of `f0000476_confidential.zip` instantly suggested a potential treasure trove, though likely password-protected. Our next move was to extract its hash using `zip2john`, a tool designed to convert ZIP archives into a hash format crackable by **John the Ripper**:

```bash
/john/run/zip2john f0000476_confidential.zip > hash.txt
```

Next, we attempted to crack the extracted hash using John the Ripper with a common wordlist (`rockyou.txt`):

```bash
$ /john/run/john --wordlist=rockyou.txt hash.txt
```

After John finished, we used `--show` to reveal the cracked password:

```bash
$ /john/run/john --show hash.txt
```

However, this attempt was unsuccessful. This led us to investigate the other recovered file, `f0000440.jpg`.

### Step 3: Analyzing the JPEG for Steganography

Given that `f0000440.jpg` was recovered alongside `f0000476_confidential.zip`, and the ZIP didnâ€™t directly yield the flag, we suspected steganography â€“ hidden data within the image. **StegSeek** is a tool specifically designed to detect and extract hidden data from JPEG files if a passphrase is used.

```bash
stegseek f0000440.jpg rockyou.txt
```

StegSeek efficiently brute-forced the `rockyou.txt` wordlist against the provided JPEG image. The output was conclusive:

```bash
StegSeek 0.6 - https://github.com/RickdeJager/StegSeek

[i] Found passphrase: "hunter"
[i] Original filename: "password.txt".
[i] Extracting to "f0000440.jpg.out".
```

StegSeek successfully found the passphrase `"hunter"` and extracted a hidden file named `password.txt` to `f0000440.jpg.out`.

### Step 4: Retrieving the Flag
Finally, we viewed the contents of the extracted file `f0000440.jpg.out`:

```bash
$ cat f0000440.jpg.out
ThisISVerySecurePassword!
```

With the password successfully obtained, we proceeded to unzip the archive:

```bash
$ unzip f0000476_confidential.zip
Archive:  f0000476_confidential.zip
[f0000476_confidential.zip] confidential.txt password: 
 extracting: confidential.txt        
```

Unzipping this file created a new directory, `f0000476_confidential`, where we found `confidential.txt`.

```bash
$ cat confidential.txt 
mmuctf{digging_through_digital_dust}
```

---

## The Verdict
The flag for the "Conundrum" challenge is 
`mmuctf{digging_through_digital_dust}`.

---

## ðŸ§© Summary

This challenge was an excellent multi-stage forensics puzzle that combined data recovery with cryptographic and steganographic challenges. The key steps involved:

1. **Data Recovery**  
   Utilizing `PhotoRec` to retrieve accidentally deleted files from a disk image.

2. **Password Cracking (ZIP)**  
   Employing `zip2john` and `John the Ripper` to attempt cracking a password-protected ZIP archive (though it was a misdirection in this case).

3. **Steganalysis**  
   Using `StegSeek` to detect and extract hidden data from a JPEG image, which yielded the correct password.

4. **Flag Retrieval**  
   Using the extracted password to unlock the ZIP archive and read the final hidden file.

The **"Conundrum"** highlighted the importance of a systematic approach to forensics, where clues can be layered and require different tools and techniques to uncover the ultimate solution.

---





# Coat of many Layers Challenge

![Coat of many Layers Challenge](/dzif8ltvg/image/upload/v1754291812/CTF/MMU%20CyberShield%20CTF/mmuctf2025-cybershield.up.railway.app_challenges_4_opav1f.png){: width="400" height="400"}

---

## Challenge Overview
The "Coat of many Layers" challenge, worth 100 points, was a classic digital forensics puzzle designed to test a participant's ability to systematically peel back multiple layers of **encoding and compression** to reveal a hidden flag. The challenge name itself served as a clear hint regarding the **layered approach** required.

---

## Task Brief
The primary objective was to uncover the hidden flag by applying various **decoding** and **decompression** techniques to the provided **binary file**, which was clearly obfuscated through several methods. The hint:

> *"To be good at forensics is enough to solve this chall? Yes. Base knowledge is needed.."*

confirmed that **fundamental forensic skills** would be key.

---

## Solve Process
The challenge began with a provided raw binary string, which served as our starting point. Our approach involved systematically identifying and reversing each layer of encoding or compression.

### Step 1: Initial Analysis â€” Binary to ASCII, ROT47, and Base32 Decoding

The initial content was presented as a long string of binary octets. Our first step was to convert this binary representation into its corresponding ASCII characters. The resulting string appeared as a jumble of readable, yet nonsensical, characters.

Given the common obfuscation techniques in CTF forensics, we suspected a character-substitution cipher. Tools like [dcode.fr's cipher identifier](https://www.dcode.fr/cipher-identifier) or [CyberChef's Magic Recipe](https://gchq.github.io/CyberChef/#recipe=Magic(3,false,false,'')) are excellent for automatically detecting such encodings. Both tools quickly pointed to **ROT47** as the initial layer.

After applying ROT47, the output began with what appeared to be a **Base32-encoded** string.

The next logical step was to decode this Base32 string from its current form. This can be achieved using various tools like CyberChef.

We performed these conversions sequentially using CyberChef:

1. **From Binary**: Converts the initial binary string into ASCII characters.  
   ![From Binary](/dzif8ltvg/image/upload/v1754307857/CTF/MMU%20CyberShield%20CTF/CyberChef/gchq.github.io_CyberChef__rzmjdn.png){: width="400" height="400"}

2. **From ROT47**: Decrypts the ASCII output from the previous step.  
   ![From ROT47](/dzif8ltvg/image/upload/v1754307523/CTF/MMU%20CyberShield%20CTF/CyberChef/gchq.github.io_CyberChef__1_zar9vv.png){: width="400" height="400"}

3. **From Base32**: Decodes the ROT47 output, revealing the raw hexadecimal data.  
   ![From Base32](/dzif8ltvg/image/upload/v1754307524/CTF/MMU%20CyberShield%20CTF/CyberChef/gchq.github.io_CyberChef__2_bg3jmt.png){: width="400" height="400"}

The final output from this multi-stage decoding process is a continuous stream of hexadecimal bytes:

```
37 7a bc af 27 1c 00 04 dd da 27 d6 20 00 00 00 00 00 00 00 6a 00 00 00 00 00 00 00 bc ce 79 6d 9b 98 b2 8a eb 8d 4a d3 e3 af 97 9f 72 99 44 78 65 85 8c 09 08 a5 ad ef 5b 95 ca 04 a6 17 5b 6f 01 04 06 00 01 09 20 00 07 0b 01 00 02 24 06 f1 07 01 12 53 0f 03 2b 72 4b f4 a2 af 00 88 7c 62 9c 2b 27 d1 3d 21 21 01 00 01 00 0c 18 14 00 08 0a 01 9c 5f 49 7c 00 00 05 01 19 01 00 11 13 00 66 00 6c 00 61 00 67 00 2e 00 74 00 78 00 74 00 00 00 19 00 14 0a 01 00 06 5e c0 a5 78 fa db 01 15 06 01 00 20 80 b4 81 00 00
```

---

### Step 2:  File Identification

With the raw hexadecimal data obtained, the next critical step was to convert it into a binary file and identify its true format. We noted the initial bytes of the hex string: `37 7a bc af 27 1c`.
Consulting resources like [Wikipedia's list of file signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) (or a similar magic byte database) immediately confirmed that these bytes are the definitive signature for a **7-Zip archive**.

![Wikipedia](/dzif8ltvg/image/upload/v1754309801/CTF/MMU%20CyberShield%20CTF/CyberChef/en.wikipedia.org_wiki_List_of_file_signatures_ju3rkt.png)

We used a small Python script to convert the full hexadecimal string into a binary file:

```python
hex_data = """
37 7a bc af 27 1c 00 04 dd da 27 d6 20 00 00 00 00 00 00 00 6a 00 00 00 00 00 00 00
bc ce 79 6d 9b 98 b2 8a eb 8d 4a d3 e3 af 97 9f 72 99 44 78 65 85 8c 09 08 a5 ad ef
5b 95 ca 04 a6 17 5b 6f 01 04 06 00 01 09 20 00 07 0b 01 00 02 24 06 f1 07 01 12 53
0f 03 2b 72 4b f4 a2 af 00 88 7c 62 9c 2b 27 d1 3d 21 21 01 00 01 00 0c 18 14 00 08
0a 01 9c 5f 49 7c 00 00 05 01 19 01 00 11 13 00 66 00 6c 00 61 00 67 00 2e 00 74 00
78 00 74 00 00 00 19 00 14 0a 01 00 06 5e c0 a5 78 fa db 01 15 06 01 00 20 80 b4 81
00 00
"""

# Clean and convert to bytes
hex_clean = hex_data.replace('\n', ' ').replace('  ', ' ').strip()
binary_data = bytes.fromhex(hex_clean)

# Save to file
with open("reconstructed.7z", "wb") as f:
    f.write(binary_data)

print("[+] File written as: reconstructed.7z")
```

We saved the file as `reconstructed.7z` (though any `.7z` extension would work). Attempting to extract it confirmed it was indeed a 7-Zip archive, producing a new file inside.

---

### Step 3: Cracking the Nested 7-Zip Archive
The extracted `reconstructed.7z` file was another archive, and as is common in CTFs, it was likely password-protected. We needed to crack its password.

First, we extracted the hash from the 7-Zip archive using `7z2john.pl`, a tool from the John the Ripper suite:

```bash
/john/run/7z2john.pl reconstructed.7z > hash.txt
```

Next, we used John the Ripper with a common wordlist (`rockyou.txt`) to crack the extracted hash:

```bash
/john/run/john --wordlist=rockyou.txt hash.txt
```

John the Ripper quickly found the password, as indicated by its output:

```bash
Press 'q' or Ctrl-C to abort, 'h' for help, almost any other key for status
kupal            (reconstructed.7z)     
1g 0:00:00:56 DONE (2025-08-01 22:32) 0.01761g/s 177.5p/s 177.5c/s 177.5C/s sammy2..chulita
```

The cracked password was `kupal`.  
Finally, we used this password to extract the contents of `reconstructed.7z`:

```bash
7z x reconstructed.7z -pkupal
```

Upon successful extraction, the flag was revealed in the `flag.txt` output file.

```bash
$ cat flag.txt 
mmuctf{0ni0n_l4y3r}
```

---

## The Verdict
The flag for the "Coat of many Layers" challenge is 
`mmuctf{0ni0n_l4y3r}`.

---

## ðŸ§© Summary

This challenge was a fantastic demonstration of layered obfuscation, requiring a methodical approach to digital forensics. The key steps involved:

1. **Multi-Stage Decoding**  
   Converting initial binary data through ASCII, ROT47, and Base32 to reveal raw hexadecimal.

2. **File Type Analysis**  
   Accurately identifying file types by prioritizing magic bytes (specifically for 7-Zip).

3. **Nested Archive Password Cracking**  
   Utilizing `7z2john.pl` and **John the Ripper** to brute-force the password of a protected 7-Zip archive.

4. **Flag Retrieval**  
   Extracting the final archive using the discovered password to reveal the flag.

> The _"Coat of many Layers"_ truly lived up to its name, emphasizing that **persistence**, a **systematic approach**, and a **keen eye for detail** (especially magic bytes!) are crucial in forensics challenges.

---